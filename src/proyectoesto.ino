/*
  proyecto seleccionador de tapas Universdiad Utepsa
  Marzo-Abril del 2021
  Integrantes:
  - Diego Gandarillas
  - Vincent Arancibia
  - Camila Lopez
  - Cesar Chavez
  - Bruno Melgar
*/

/*
* COSAS QUE LE FALTAN AL CODIGO
*	LECTURA DEL SENSOR
*	CONTROL DEL SERVO
*/

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_I2CDevice.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

//Inputs del Encoder
#define inputBT 2
#define inputDT 5
#define inputCLK 6

//Inputs Servomotores
#define servo1 10
#define servo2 11

//Pines sensor de color
#define outsensor 9
#define s0 13
#define s1 12
#define s2 8
#define s3 7


//variables encoder
int previoCLK;
int previoDT;
int pantalla = 1;
int subpantalla = 0;
int banderaboton = 3;

//variables de colores
int rojo = 0;
int amarillo = 0;
int otro = 0;

//test contador
int ubicacion[5] = {10, 30, 50, 70, 90}; //posicion de opciones menu
long TimeOfLastDebounce = 0;			 //mantiene la ultima vez que el switch fue presionado
long DelayOfDebounce = 0.5;				 //cantidad de tiempo que se tiene que esperar entre presiones del boton

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C //0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// 'utepsa_logo', 64x64px
#define utepsa_h 64
#define utepsa_w 64
const unsigned char utepsa[] PROGMEM = {
	0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
	0x00, 0x78, 0x00, 0x1f, 0xf8, 0x00, 0x1e, 0x00, 0x00, 0x7e, 0x00, 0x3e, 0x7c, 0x00, 0x7e, 0x00,
	0x00, 0x3f, 0xc0, 0x3e, 0x7c, 0x03, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x7c, 0x3e, 0x1f, 0xfc, 0x00,
	0x00, 0x3f, 0xfe, 0x7c, 0x3e, 0x7f, 0xfc, 0x00, 0x00, 0x1f, 0xff, 0xf8, 0x1f, 0xff, 0xf8, 0x00,
	0x00, 0x1f, 0xff, 0xf8, 0x1f, 0xff, 0xf8, 0x00, 0x00, 0x1f, 0x7f, 0xf0, 0x0f, 0xfe, 0xf8, 0x00,
	0x00, 0x1f, 0x9f, 0xf0, 0x0f, 0xf9, 0xf8, 0x00, 0x00, 0x0f, 0x83, 0xe0, 0x07, 0xc1, 0xf0, 0x00,
	0x00, 0x0f, 0x80, 0xe0, 0x07, 0x01, 0xf0, 0x00, 0x00, 0x0f, 0x80, 0x40, 0x02, 0x01, 0xf0, 0x00,
	0x00, 0x0f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x03, 0xe0, 0x00,
	0x00, 0x07, 0xc0, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00,
	0x00, 0x3f, 0xe0, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x01, 0xff, 0xe1, 0xe0, 0x07, 0x87, 0xff, 0x80,
	0x07, 0xff, 0x81, 0xe0, 0x07, 0x81, 0xff, 0xe0, 0x3f, 0xfc, 0x01, 0xe0, 0x07, 0x80, 0x3f, 0xfc,
	0xff, 0xe0, 0x01, 0xe0, 0x07, 0x80, 0x07, 0xff, 0x7f, 0x00, 0x01, 0xe0, 0x07, 0x80, 0x00, 0xfe,
	0x3f, 0x80, 0x01, 0xe0, 0x07, 0x80, 0x01, 0xfc, 0x1f, 0xc0, 0x01, 0xe0, 0x07, 0x80, 0x03, 0xf8,
	0x07, 0xf0, 0x01, 0xe0, 0x07, 0x80, 0x0f, 0xe0, 0x03, 0xf8, 0x01, 0xe0, 0x07, 0x80, 0x1f, 0xc0,
	0x01, 0xfc, 0x01, 0xe0, 0x07, 0x80, 0x3f, 0x80, 0x00, 0xff, 0x01, 0xe0, 0x07, 0x80, 0xff, 0x00,
	0x00, 0x3f, 0x81, 0xe0, 0x07, 0x81, 0xfc, 0x00, 0x00, 0x1f, 0x01, 0xe0, 0x07, 0x80, 0xf8, 0x00,
	0x00, 0x3f, 0x01, 0xf0, 0x0f, 0x80, 0xfc, 0x00, 0x00, 0x3e, 0x01, 0xf8, 0x1f, 0x80, 0x7c, 0x00,
	0x00, 0x7c, 0x00, 0xff, 0xff, 0x00, 0x3e, 0x00, 0x00, 0xf8, 0x00, 0x7f, 0xfe, 0x00, 0x1f, 0x00,
	0x00, 0xf8, 0x00, 0x3f, 0xfc, 0x00, 0x1f, 0x00, 0x01, 0xf0, 0x00, 0x0f, 0xf0, 0x00, 0x0f, 0x80,
	0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x07, 0xc0, 0x3c, 0x00, 0x00, 0x3c, 0x03, 0xe0,
	0x07, 0xcf, 0xfc, 0x00, 0x00, 0x3f, 0xf3, 0xe0, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xf0,
	0x1f, 0xff, 0xfc, 0x01, 0x80, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xfc, 0x03, 0xc0, 0x3f, 0xff, 0xf8,
	0x3f, 0xfe, 0x3c, 0x07, 0xe0, 0x3c, 0x7f, 0xfc, 0x1e, 0x00, 0x3e, 0x0f, 0xf0, 0x7c, 0x00, 0x78,
	0x00, 0x00, 0x3e, 0x3f, 0xfc, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7e, 0x7e, 0x78, 0x00, 0x00,
	0x00, 0x00, 0x1e, 0xfc, 0x3f, 0x78, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x1f, 0xf8, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x07, 0xf8, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xe0, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0xf8, 0x00, 0x00,
	0x00, 0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00,
	0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x30, 0x00, 0x00};

//funciones
void menu()
{
	//se ha movido el encoder
	int nuevoCLK = digitalRead(inputCLK);
	int nuevoDT = digitalRead(inputDT);

	if (nuevoCLK != previoCLK && (millis() - TimeOfLastDebounce) > DelayOfDebounce)
	{
		Serial.print("CLK pin:");
		Serial.println(nuevoCLK);
		Serial.print("DT pin:");
		Serial.println(nuevoDT);

		//test contador
		if (nuevoCLK == 0 && nuevoDT == 0)
		{
			for (int i = 0; i < 5; i++)
			{
				ubicacion[i] = ubicacion[i] + 20;
				if (ubicacion[i] > 90)
				{
					ubicacion[i] = 10;
				}
			}
		}
		if (nuevoCLK == 0 && nuevoDT == 1)
		{
			for (int i = 0; i < 5; i++)
			{
				ubicacion[i] = ubicacion[i] - 20;
				if (ubicacion[i] < 10)
				{
					ubicacion[i] = 90;
				}
			}
		}

		//debug
		Serial.print(millis() / 1000);
		Serial.println("---------------");

		//actualizar el tiempo de debounce
		previoCLK = nuevoCLK;
		previoDT = nuevoDT;
		TimeOfLastDebounce = millis();

		//dibujar la pantalla
		pantallas();
	}
}

void pantallas()
{
	//menuprincipal
	if (pantalla == 1)
	{
		display.clearDisplay();

		display.setTextSize(2); //2X-scale text
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(15, ubicacion[0]);
		display.println(F("Iniciar"));
		display.setCursor(15, ubicacion[1]);
		display.println(F("Parar"));
		display.setCursor(15, ubicacion[2]);
		display.println(F("Rojo"));
		display.setCursor(15, ubicacion[3]);
		display.println(F("Amarillo"));
		display.setCursor(15, ubicacion[4]);
		display.println(F("Otro"));
		display.setCursor(0, 30);
		display.println(F(">"));

		display.display(); //dibujar pantalla

		delay(100);
	}

	//submenus
	if (subpantalla == 1)
	{

		display.clearDisplay();

		display.setTextSize(2);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(15, 10);
		display.println(F("Cantidad"));
		display.setCursor(15, 30);
		display.println(F("Rojo"));
		display.setCursor(15, 50);
		display.println(rojo);

		display.display();

		delay(100);
	}
	else if (subpantalla == 2)
	{

		display.clearDisplay();

		display.setTextSize(2);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(15, 10);
		display.println(F("Cantidad"));
		display.setCursor(15, 30);
		display.println(F("Amarillo"));
		display.setCursor(15, 50);
		display.println(amarillo);

		display.display();

		delay(100);
	}
	else if (subpantalla == 3)
	{

		display.clearDisplay();

		display.setTextSize(2);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(15, 10);
		display.println(F("Cantidad"));
		display.setCursor(15, 30);
		display.println(F("Otro"));
		display.setCursor(15, 50);
		display.println(otro);

		display.display();

		delay(100);
	}
}

void setup()
{
	Serial.begin(9600);
	//encoder pins as inputs
	pinMode(inputCLK, INPUT);
	pinMode(inputDT, INPUT);

	//entrada encoder
	pinMode(2, INPUT_PULLUP);

	//incializar valores previos
	previoCLK = digitalRead(inputCLK);
	previoDT = digitalRead(inputDT);

	//SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
	if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
	{
		Serial.println(F("SSD1306 allocation failed"));
		for (;;)
			; // Don't proceed, loop forever
	}

	//initial screen
	display.clearDisplay();
	display.drawBitmap((display.width() - utepsa_w) / 2, (display.height() - utepsa_h) / 2, utepsa, utepsa_w, utepsa_h, 1);
	display.display();
	delay(1000);
}

void loop()
{
	//si el botón se presiona se sale del submenu al menu principal
	if (digitalRead(inputBT) == LOW && banderaboton == 0) //boton presionado y bandera 0 salir del submenu (ifs de mas abajo)
	{
		banderaboton = 2;
	}
	if (digitalRead(inputBT) == LOW && banderaboton == 3) //botón presionado y bandera inicial entrar al submenu (ifs de mas abajo)
	{
		banderaboton = 1;
	}

	if (digitalRead(inputBT) != LOW && banderaboton == 1) //botón suelto y bandera arriba redundancia para que no se reinicie hasta soltar el botón
	{
		banderaboton = 0;
	}
	if (digitalRead(inputBT) != LOW && banderaboton == 2) //botón suelto y bandera arriba redundancia para que no entre de nuevo al menu
	{
		banderaboton = 3;
	}

	//seleccion si el botón no está presionado y dependiendo de dónde esté en el menu ir al submenu
	if (banderaboton == 1 && ubicacion[2] == 30)
	{
		pantalla = 0;
		subpantalla = 1;
		pantallas();
	}
	if (banderaboton == 1 && ubicacion[3] == 30)
	{
		pantalla = 0;
		subpantalla = 2;
		pantallas();
	}
	if (banderaboton == 1 && ubicacion[4] == 30)
	{
		pantalla = 0;
		subpantalla = 3;
		pantallas();
	}

	//volver al menu principal si se presiona el encoder y estamos en un submenu
	if (banderaboton == 2 && subpantalla != 0)
	{
		pantalla = 1;
		subpantalla = 0;
		pantallas();
	}

	//calcular menu
	menu();
}
